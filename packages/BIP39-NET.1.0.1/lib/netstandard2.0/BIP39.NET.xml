<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BIP39.NET</name>
    </assembly>
    <members>
        <member name="T:Bitcoin.BitcoinUtilities.Base58">
            <summary>
            A custom form of base58 is used to encode BitCoin addresses. Note that this is not the same base58 as used by
            Flickr, which you may see reference to around the internet.
            </summary>
            <remarks>
            Satoshi says: why base-58 instead of standard base-64 encoding?<p/>
            <ul>
              <li>Don't want 0OIl characters that look the same in some fonts and
                could be used to create visually identical looking account numbers.</li>
              <li>A string with non-alphanumeric characters is not as easily accepted as an account number.</li>
              <li>E-mail usually won't line-break if there's no punctuation to break at.</li>
              <li>Double clicking selects the whole number as one word if it's all alphanumeric.</li>
            </ul>
            </remarks>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Base58.Decode(System.String)">
            <exception cref="!:AddressFormatException"/>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Base58.DecodeToBigInteger(System.String)">
            <exception cref="!:AddressFormatException"/>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Base58.DecodeChecked(System.String)">
            <summary>
            Uses the checksum in the last 4 bytes of the decoded data to verify the rest are correct. The checksum is
            removed from the returned data.
            </summary>
            <exception cref="!:AddressFormatException">If the input is not base 58 or the checksum does not validate.</exception>
        </member>
        <member name="T:Bitcoin.BitcoinUtilities.EcKeyPair">
            <summary>
            Represents an elliptic curve keypair that we own and can use for signing transactions. Currently,
            Bouncy Castle is used. In future this may become an interface with multiple implementations using different crypto
            libraries. The class also provides a static method that can verify a signature with just the public key.
            </summary>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.EcKeyPair.#ctor(System.Boolean)">
            <summary>
            Generates an entirely new keypair.
            </summary>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.EcKeyPair.#ctor(System.Byte[],System.Boolean)">
            <summary>
            Creates an ECKey given only the private key in a universlly friendly byte array form. This works because
            EC public keys are derivable from their private keys by doing a multiply with the generator value.
            </summary>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.EcKeyPair.GetPublicKeyBytesFromPrivateKeyBytes(System.Byte[],System.Boolean)">
            <summary>
            Returns the raw public key bytes from private key bytes
            </summary>
            <param name="privateKey">The private key bytes to derive public key from</param>
            <param name="compressedPublicKey">Force the public key to be compressed, default is true</param>
            <returns>public key bytes</returns>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.EcKeyPair.pPublicKeyFromPrivate(Org.BouncyCastle.Math.BigInteger,System.Boolean)">
            <summary>
            Derive the public key by doing a point multiply of G * priv.
            </summary>
        </member>
        <member name="P:Bitcoin.BitcoinUtilities.EcKeyPair.PublicKey">
            <summary>
            Gets the raw public key value. This appears in transaction scriptSigs. Note that this is <b>not</b> the same
            as the pubKeyHash/address.
            </summary>
        </member>
        <member name="P:Bitcoin.BitcoinUtilities.EcKeyPair.IsCompressedPublicKey">
            <summary>
            Gets the status of compression of the public key
            </summary>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.EcKeyPair.Sign(System.Byte[])">
            <summary>
            Calculates an ECDSA signature in DER format for the given input hash. Note that the input is expected to be
            32 bytes long.
            </summary>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.EcKeyPair.Verify(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Verifies the given ASN.1 encoded ECDSA signature against a hash using the public key.
            </summary>
            <param name="data">Hash of the data to verify.</param>
            <param name="signature">ASN.1 encoded signature.</param>
            <param name="pub">The public key bytes to use.</param>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.EcKeyPair.Verify(System.Byte[],System.Byte[])">
            <summary>
            Verifies the given ASN.1 encoded ECDSA signature against a hash using the public key.
            </summary>
            <param name="data">Hash of the data to verify.</param>
            <param name="signature">ASN.1 encoded signature.</param>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.EcKeyPair.pGetPrivateKeyBytes">
            <summary>
            Returns a 32 byte array containing the private key.
            </summary>
        </member>
        <member name="T:Bitcoin.BitcoinUtilities.Rfc2898_pbkdf2_hmacsha512">
            <summary>
            Implementation of the Rfc2898 PBKDF2 specification located here http://www.ietf.org/rfc/rfc2898.txt using HMACSHA512 but modified as opposed to PWDTKto match the BIP39 test vectors
            Using BouncyCastle for the HMAC-SHA512 instead of Microsoft implementation
            NOTE NOT IDENTICLE TO PWDTK (PWDTK is concatenating password and salt together before hashing the concatenated byte block, this is simply hashing the salt as what we are told to do in BIP39, yes the mnemonic sentence is provided as the hmac key)
            Created by thashiznets@yahoo.com.au
            v1.1.0.0
            Bitcoin:1ETQjMkR1NNh4jwLuN5LxY7bbip39HC9PUPSV
            </summary>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Rfc2898_pbkdf2_hmacsha512.#ctor(System.Byte[],System.Byte[],System.Int32)">
            <summary>
            Constructor to create Rfc2898_pbkdf2_hmacsha512 object ready to perform Rfc2898 PBKDF2 functionality
            </summary>
            <param name="password">The Password to be hashed and is also the HMAC key</param>
            <param name="salt">Salt to be concatenated with the password</param>
            <param name="iterations">Number of iterations to perform HMACSHA Hashing for PBKDF2</param>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Rfc2898_pbkdf2_hmacsha512.GetDerivedKeyBytes_PBKDF2_HMACSHA512(System.Int32)">
            <summary>
            Derive Key Bytes using PBKDF2 specification listed in Rfc2898 and HMACSHA512 as the underlying PRF (Psuedo Random Function)
            </summary>
            <param name="keyLength">Length in Bytes of Derived Key</param>
            <returns>Derived Key</returns>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Rfc2898_pbkdf2_hmacsha512.PBKDF2(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <summary>
            A static publicly exposed version of GetDerivedKeyBytes_PBKDF2_HMACSHA512 which matches the exact specification in Rfc2898 PBKDF2 using HMACSHA512
            </summary>
            <param name="P">Password passed as a Byte Array</param>
            <param name="S">Salt passed as a Byte Array</param>
            <param name="c">Iterations to perform the underlying PRF over</param>
            <param name="dkLen">Length of Bytes to return, an AES 256 key wold require 32 Bytes</param>
            <returns>Derived Key in Byte Array form ready for use by chosen encryption function</returns>
        </member>
        <member name="T:Bitcoin.BitcoinUtilities.Utilities">
            <summary>
            A Library that provides common functionality between my other Bitcoin Modules
            Made by thashiznets@yahoo.com.au
            v1.0.0.2
            Bitcoin:1ETQjMkR1NNh4jwLuN5LxY7bMsHC9PUPSV
            </summary>  
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.Sha256Hash160(System.Byte[])">
            <summary>
            Calculates RIPEMD160(SHA256(input)). This is used in Address calculations.
            </summary>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.Sha256Digest(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Calculates the SHA256 32 byte checksum of the input bytes
            </summary>
            <param name="input">bytes input to get checksum</param>
            <param name="offset">where to start calculating checksum</param>
            <param name="length">length of the input bytes to perform checksum on</param>
            <returns>32 byte array checksum</returns>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.Sha512Digest(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Calculates the SHA512 64 byte checksum of the input bytes
            </summary>
            <param name="input">bytes input to get checksum</param>
            <param name="offset">where to start calculating checksum</param>
            <param name="length">length of the input bytes to perform checksum on</param>
            <returns>64 byte array checksum</returns>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.DoubleDigest(System.Byte[])">
            <summary>
            See <see cref="M:Bitcoin.BitcoinUtilities.Utilities.DoubleDigest(System.Byte[],System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.DoubleDigest(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Calculates the SHA-256 hash of the given byte range, and then hashes the resulting hash again. This is
            standard procedure in BitCoin. The resulting hash is in big endian form.
            </summary>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.DoubleDigestTwoBuffers(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Calculates SHA256(SHA256(byte range 1 + byte range 2)).
            </summary>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.DecodeMpi(System.Byte[])">
            <summary>
            MPI encoded numbers are produced by the OpenSSL BN_bn2mpi function. They consist of
            a 4 byte big endian length field, followed by the stated number of bytes representing
            the number in big endian format.
            </summary>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.HexStringToBytes(System.String)">
            <summary>
            Converts a hex based string into its bytes contained in a byte array
            </summary>
            <param name="hex">The hex encoded string</param>
            <returns>the bytes derived from the hex encoded string</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Bitcoin.BitcoinUtilities.Utilities.BytesToHexString(System.Byte[],System.Boolean)" -->
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.HmacSha512Digest(System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>
            Calculates the 64 byte checksum in accordance with HMAC-SHA512
            </summary>
            <param name="input">The bytes to derive the checksum from</param>
            <param name="offset">Where to start calculating checksum in the input bytes</param>
            <param name="length">Length of buytes to use to calculate checksum</param>
            <param name="hmacKey">HMAC Key used to generate the checksum (note differing HMAC Keys provide unique checksums)</param>
            <returns></returns>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.GetRandomBytes(System.Int32,System.Int32)">
            <summary>
            Safely get Crypto Random byte array at the size you desire.
            </summary>
            <param name="size">Size of the crypto random byte array to build</param>
            <param name="seedStretchingIterations">Optional parameter to specify how many SHA512 passes occur over our seed before we use it. Higher value is greater security but uses more computational power. If random byte generation is taking too long try specifying values lower than the default of 5000. You can set 0 to turn off stretching</param>
            <returns>A byte array of completely random bytes</returns>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.GetRandomBytesAsync(System.Int32,System.Int32)">
            <summary>
            Safely get Crypto Random byte array at the size you desire, made this async version because can take 500ms to complete and so this allows non-blocking for the 500ms.
            </summary>
            <param name="size">Size of the crypto random byte array to build</param>
            <param name="seedStretchingIterations">Optional parameter to specify how many SHA512 passes occur over our seed before we use it. Higher value is greater security but uses more computational power. If random byte generation is taking too long try specifying values lower than the default of 5000. You can set 0 to turn off stretching</param>
            <returns>A byte array of completely random bytes</returns>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.MergeByteArrays(System.Byte[],System.Byte[])">
            <summary>
            Merges two byte arrays
            </summary>
            <param name="source1">first byte array</param>
            <param name="source2">second byte array</param>
            <returns>A byte array which contains source1 bytes followed by source2 bytes</returns>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.SwapEndianBytes(System.Byte[])">
            <summary>
            This switches the Endianess of the provided byte array, byte per byte we do bit swappy.
            </summary>
            <param name="bytes">Bytes to change endianess of</param>
            <returns>Bytes with endianess swapped</returns>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.NewPositiveBigInteger(System.Byte[])">
            <summary>
            Returns a Positive BouncyCastle BigInteger
            </summary>
            <param name="bytes">Bytes to create BigInteger</param>
            <returns>A Positive BigInteger</returns>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.ToUnixTime(System.DateTime)">
            <summary>
            Convert a .NET DateTime into a Unix Epoch represented time
            </summary>
            <param name="time">DateTime to convert</param>
            <returns>Number of ticks since the Unix Epoch</returns>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.UnixTimeWithin70MinuteThreshold(System.UInt64,System.Int64@)">
            <summary>
            Checks to see if supplied time is within the 70 minute tollerance for network error
            </summary>
            <param name="peerUnixTime">Unix time to check within threshold</param>
            <param name="timeOffset">Offset which is difference between peerUnixTime and local UTC time</param>
            <returns>Compliance within threshold</returns>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.NormaliseStringNfkd(System.String)">
            <summary>
            Normalises a string with NKFD normal form
            </summary>
            <param name="toNormalise">String to be normalised</param>
            <returns>Normalised string</returns>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.Uint32ToByteArrayLe(System.UInt32,System.Byte[],System.Int32)">
            <summary>
            Uint32 to Byte Array in Little Endian
            </summary>
            <param name="val">the uint32 to convert</param>
            <param name="@out">The byte array representation of uint32 in little endian</param>
            <param name="offset">Offset to start placing the bytes in the byte array</param>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.Uint32ToByteStreamLe(System.UInt32,System.IO.Stream)">
            <summary>
            Converts a Uint32 into a Stream of Bytes in Little Endian
            </summary>
            <param name="val">Uint32 to make stream</param>
            <param name="stream">Uint32 outout as byte stream little endian</param>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.Uint32ToByteArrayBe(System.UInt32,System.Byte[],System.Int32)">
            <summary>
            Converts a Uint32 into a Byte Array in Big Endian
            </summary>
            <param name="val">Uint32 to convert</param>
            <param name="@out">Byte array that will contain the result of the conversion</param>
            <param name="offset">Offset in byte array to start placing output</param>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.Uint64ToByteStreamLe(System.UInt64,System.IO.Stream)">
            <summary>
            Convert a ulong to byte stream little endian
            </summary>
            <param name="val">ulong for conversion</param>
            <param name="stream">byte stream of ulong in little endian order</param>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.ReadUint32(System.Byte[],System.Int32)">
            <summary>
            Bytes to Uint32
            </summary>
            <param name="bytes">Bytes to get Uint32 from</param>
            <param name="offset">Offset to start getting the UInt32 from</param>
            <returns>Uint32</returns>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.ReadUint32Be(System.Byte[],System.Int32)">
            <summary>
            Bytes to Uint32 in BigEndian format
            </summary>
            <param name="bytes">Bytes to get Uint32 from</param>
            <param name="offset">Offset to start getting the UInt32 from</param>
            <returns>Uint32</returns>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.ReverseBytes(System.Byte[])">
            <summary>
            Reverse the order of given Byte Array
            </summary>
            <param name="bytes">Byte array to reverse</param>
            <returns>reverse copy of supplied Byte array</returns>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.Utilities.NormalizeString(Bitcoin.BitcoinUtilities.Globals.NORM_FORM,System.String,System.Int32,System.Text.StringBuilder,System.Int32)">
            <summary>
            Will be used internally for NFKD Normalisation
            </summary>
            <param name="NormForm">Normal Form to use</param>
            <param name="lpSrcString">Raw non-normalised source string</param>
            <param name="cwSrcLength">Length of source string</param>
            <param name="lpDstString">Normalised destination string</param>
            <param name="cwDstLength">length of destination string</param>
            <returns>length of result string</returns>
        </member>
        <member name="T:Bitcoin.BitcoinUtilities.VersionedChecksummedBytes">
            <summary>
            In BitCoin the following format is often used to represent some type of key:<p/>
            <pre>[one version byte] [data bytes] [4 checksum bytes]</pre><p/>
            and the result is then Base58 encoded. This format is used for addresses, and private keys exported using the
            "dumpprivkey" command.
            </summary>
        </member>
        <member name="M:Bitcoin.BitcoinUtilities.VersionedChecksummedBytes.#ctor(System.String)">
            <exception cref="!:AddressFormatException"/>
        </member>
        <member name="P:Bitcoin.BitcoinUtilities.VersionedChecksummedBytes.Version">
            <summary>
            Returns the "version" or "header" byte: the first byte of the data. This is used to disambiguate what the
            contents apply to, for example, which network the key or address is valid on.
            </summary>
            <returns>A positive number between 0 and 255.</returns>
        </member>
        <member name="T:Bitcoin.BIP39.BIP39">
            <summary>
            A .NET implementation of the Bitcoin Improvement Proposal - 39 (BIP39)
            BIP39 specification used as reference located here: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
            Made by thashiznets@yahoo.com.au
            v1.0.1.1
            I ♥ Bitcoin :)
            Bitcoin:1ETQjMkR1NNh4jwLuN5LxY7bMsHC9PUPSV
            </summary>
        </member>
        <member name="M:Bitcoin.BIP39.BIP39.#ctor(System.Int32,System.String,Bitcoin.BIP39.BIP39.Language)">
            <summary>
            Constructor to build a BIP39 object from scratch given an entropy size and an optional passphrase. Language is optional and will default to English
            </summary>
            <param name="entropySize">The size in bits of the entropy to be created</param>
            <param name="passphrase">The optional passphrase. Please ensure NFKD Normalized, Empty string will be used if not provided as per spec</param>
            <param name="language">The optional language. If no language is provided English will be used</param>
        </member>
        <member name="M:Bitcoin.BIP39.BIP39.#ctor(System.Byte[],System.String,Bitcoin.BIP39.BIP39.Language)">
            <summary>
            Constructor to build a BIP39 object using supplied entropy bytes eighter from a previously created BIP39 object or another method of entropy generation.
            </summary>
            <param name="entropyBytes">The entropy bytes which will determine the mnemonic sentence</param>
            <param name="passphrase">The optional passphrase. Please ensure NFKD Normalized, Empty string will be used if not supplied as per spec</param>
            <param name="language">The optional language. If no language is provided English will be used</param>
        </member>
        <member name="M:Bitcoin.BIP39.BIP39.#ctor(System.String,System.String,Bitcoin.BIP39.BIP39.Language)">
            <summary>
            Constructor to build a BIP39 object using a supplied Mnemonic sentence and passphrase. If you are not worried about saving the entropy bytes, or using custom words not in a wordlist, you should consider the static method to do this instead.
            </summary>
            <param name="mnemonicSentence">The mnemonic sentencs used to derive seed bytes, Please ensure NFKD Normalized</param>
            <param name="passphrase">Optional passphrase used to protect seed bytes, defaults to empty</param>
            <param name="language">Optional language to use for wordlist, if not specified it will auto detect language and if it can't detect it will default to English</param>
        </member>
        <member name="M:Bitcoin.BIP39.BIP39.GetBIP39Async(System.Int32,System.String,Bitcoin.BIP39.BIP39.Language)">
            <summary>
            An asynchronous static method to create a new BIP39 from random entropy. The random entropy creation is CPU intensive so is run in its own Task and we await as per async pattern.
            </summary>
            <param name="entropySize">The size in bits of the entropy to be created</param>
            <param name="passphrase">The optional passphrase. Please ensure NFKD Normalized, Empty string will be used if not provided as per spec</param>
            <param name="language">The optional language. If no language is provided English will be used</param>
            <returns>A BIP39 object</returns>
        </member>
        <member name="M:Bitcoin.BIP39.BIP39.AutoDetectLanguageOfWords(System.String[])">
            <summary>
            Takes in a string[] of words and detects the language that has the highest number of matching words.
            </summary>
            <param name="words">The words of which you wish to derive a language</param>
            <returns>The best attempt at a guessed Language</returns>
        </member>
        <member name="M:Bitcoin.BIP39.BIP39.GetSeedBytes(System.String,System.String)">
            <summary>
            Supply a mnemonic sentence with any words of your choosing not restricted to wordlists and be given seed bytes in return
            </summary>
            <param name="mnemonicSentence">The mnemonic sentence we will use to derive seed bytes, Please ensure NFKD Normalized</param>
            <param name="passphrase">Optional passphrase to protect the seed bytes, Please ensure NFKD Normalized, defaults to empty string</param>
            <returns>Seed bytes that can be used to create a root in BIP32</returns>
        </member>
        <member name="M:Bitcoin.BIP39.BIP39.GetSeedBytesHexString(System.String,System.String)">
            <summary>
            Supply a mnemonic sentence with any words of your choosing not restricted to wordlists and be given seed bytes hex encoded as a string in return
            </summary>
            <param name="mnemonicSentence">The mnemonic sentence we will use to derive seed bytes</param>
            <param name="passphrase">Optional passphrase to protect the seed bytes, defaults to empty string</param>
            <returns>Hex string encoded seed bytes that can be used to create a root in BIP32</returns>
        </member>
        <member name="M:Bitcoin.BIP39.BIP39.pInit(System.String,Bitcoin.BIP39.BIP39.Language)">
            <summary>
            Common initialisation code utilised by all the constructors. It gets all the bits and does a checksum etc. This is the main code to create a BIP39 object.
            </summary>
        </member>
        <member name="M:Bitcoin.BIP39.BIP39.pGetMnemonicSentence">
            <summary>
            Uses the Wordlist Index to create a scentence ow words provided by the wordlist of this objects language attribute
            </summary>
            <returns>A scentence of words</returns>
        </member>
        <member name="M:Bitcoin.BIP39.BIP39.pGetWordIndeces(System.Collections.BitArray)">
            <summary>
            Process entropy + CS into an index list of words to get from wordlist
            </summary>
            <returns>An index, each int is a line in the wiordlist for the language of choice</returns>
        </member>
        <member name="M:Bitcoin.BIP39.BIP39.pRebuildWordIndexes(System.String[])">
            <summary>
            Takes in the words of a mnemonic sentence and it rebuilds the word index, having the valid index allows us to hot swap between languages/word lists :)
            </summary>
            <param name="wordsInMnemonicSentence"> a string array containing each word in the mnemonic sentence</param>
            <returns>The word index that can be used to build the mnemonic sentence</returns>
        </member>
        <member name="M:Bitcoin.BIP39.BIP39.pProcessBitsToInt(System.Collections.BitArray)">
            <summary>
            Me encoding an integer between 0 and 2047 from 11 bits...
            </summary>
            <param name="bits">The bits to encode into an integer</param>
            <returns>integer between 0 and 2047</returns>
        </member>
        <member name="M:Bitcoin.BIP39.BIP39.pProcessIntToBitsThenBytes(System.Collections.Generic.List{System.Int32})">
            <summary>
            Takes the word index and decodes it from our 11 bit integer encoding back into raw bits including CS. Then it removes CS bits and turns back into entropy bytes
            </summary>
            <param name="wordIndex">The word index to convert back to bits then bytes</param>
            <returns>entropy bytes excluding CS</returns>
        </member>
        <member name="P:Bitcoin.BIP39.BIP39.EntropyBytes">
            <summary>
            Gets the entropy bytes, they can be used to reconstruct this object, providing these bytes and passphrase is all that is needed
            </summary>
        </member>
        <member name="P:Bitcoin.BIP39.BIP39.Passphrase">
            <summary>
            Sets the pasphrase, this lets us use the same entropy bits to derive many seeds based on different passphrases
            </summary>
        </member>
        <member name="P:Bitcoin.BIP39.BIP39.MnemonicSentence">
            <summary>
            Gets the mnemonic sentence built from ent+cs
            </summary>
        </member>
        <member name="P:Bitcoin.BIP39.BIP39.WordlistLanguage">
            <summary>
            Gets or Sets the language that will be used to provide the mnemonic sentence, WARNING ensure you get new seed bytes after setting language
            </summary>
        </member>
        <member name="P:Bitcoin.BIP39.BIP39.SeedBytes">
            <summary>
            Gets the bytes of the seed created from the mnemonic sentence. This could become your root in BIP32
            </summary>
        </member>
        <member name="P:Bitcoin.BIP39.BIP39.SeedBytesHexString">
            <summary>
            Gets a hex encoded string of the seed bytes
            </summary>
        </member>
        <member name="P:Bitcoin.BIP39.BIP39.WordCountFromEntropy">
            <summary>
            Gets a count of the words that the entropy will produce
            </summary>
        </member>
        <member name="T:Bitcoin.BIP39.Wordlists.ChineseSimplified">
            <summary>
            The Chinese Simplified wordlist, note the inheritance as all wordlists share functionality language dependent
            </summary>
        </member>
        <member name="M:Bitcoin.BIP39.Wordlists.ChineseSimplified.#ctor">
            <summary>
            Creates an English wordlist to work with
            </summary>
        </member>
        <member name="T:Bitcoin.BIP39.Wordlists.ChineseTraditional">
            <summary>
            The Chinese Traditional wordlist, note the inheritance as all wordlists share functionality language dependent
            </summary>
        </member>
        <member name="M:Bitcoin.BIP39.Wordlists.ChineseTraditional.#ctor">
            <summary>
            Creates an English wordlist to work with
            </summary>
        </member>
        <member name="T:Bitcoin.BIP39.Wordlists.English">
            <summary>
            The English wordlist, note the inheritance as all wordlists share functionality language dependent
            </summary>
        </member>
        <member name="M:Bitcoin.BIP39.Wordlists.English.#ctor">
            <summary>
            Creates an English wordlist to work with
            </summary>
        </member>
        <member name="T:Bitcoin.BIP39.Wordlists.French">
            <summary>
            The spanish wordlist, note the inheritance as all wordlists share functionality language dependent, also note the accented characters
            </summary>
        </member>
        <member name="M:Bitcoin.BIP39.Wordlists.French.#ctor">
            <summary>
            Creates a Spanish wordlist to work with
            </summary>
        </member>
        <member name="T:Bitcoin.BIP39.Wordlists.Japanese">
            <summary>
            The Japanese wordlist, note the inheritance as all wordlists share functionality language dependent
            </summary>
        </member>
        <member name="M:Bitcoin.BIP39.Wordlists.Japanese.#ctor">
            <summary>
            Creates a Japanese wordlist to work with
            </summary>
        </member>
        <member name="T:Bitcoin.BIP39.Wordlists.Spanish">
            <summary>
            The spanish wordlist, note the inheritance as all wordlists share functionality language dependent, also note the accented characters
            </summary>
        </member>
        <member name="M:Bitcoin.BIP39.Wordlists.Spanish.#ctor">
            <summary>
            Creates a Spanish wordlist to work with
            </summary>
        </member>
        <member name="M:Bitcoin.BIP39.Wordlists.Wordlist.#ctor(System.String[])">
            <summary>
            Constructor used by inheritence only
            </summary>
            <param name="words">The words to be used in the wordlist</param>
        </member>
        <member name="M:Bitcoin.BIP39.Wordlists.Wordlist.WordExists(System.String,System.Int32@)">
            <summary>
            Method to determine if word exists in word list, great for auto language detection
            </summary>
            <param name="word">The word to check for existence</param>
            <returns>Exists (true/false)</returns>
        </member>
        <member name="M:Bitcoin.BIP39.Wordlists.Wordlist.GetWordAtIndex(System.Int32)">
            <summary>
            Returns a string containing the word at the specified index of the wordlist
            </summary>
            <param name="index">Index of word to return</param>
            <returns>Word</returns>
        </member>
        <member name="P:Bitcoin.BIP39.Wordlists.Wordlist.WordCount">
            <summary>
            The number of all the words in the wordlist
            </summary>
        </member>
    </members>
</doc>
